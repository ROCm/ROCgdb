# Copyright (C) 2019-2020 Free Software Foundation, Inc.
# Copyright (C) 2019-2020 Advanced Micro Devices, Inc. All rights reserved.

# This file is part of GDB.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# exp_internal 1

load_lib rocm.exp

set testfile "nonstop-mode"
set srcfile ${srcdir}/${subdir}/${testfile}.cpp
set objfile [standard_output_file ${testfile}.o]
set binfile [standard_output_file ${testfile}]

set wave_id {(0,0,0)/0}
set rocm_threadno {1:1:1:5}
set threadid {16}

# Check if skip hip tests
if [skip_hipcc_tests] {
    verbose "Skipping hip test: ${testfile}."
    return 0
}

# Compile the hip program
if {[prepare_for_testing "failed to prepare ${testfile}" $testfile $srcfile {debug hip}]} {
    return -1
}

gdb_start

# Load the hip program
if {[gdb_load ${binfile}] == -1} {
    verbose "failed to load program ${testfile}."
    return -1
}

with_rocm_gpu_lock {

# Run to main and break
if ![runto_main] {
    fail "can't run to main and break in program ${testfile}."
    return -1
}


# Code to fetch threadno and corresponding wave_id.
# Set breakpoint in device code.
gdb_breakpoint "VectorAdd" "allow-pending"
gdb_test "continue" {.+hit\sBreakpoint\s\d+.+\sVectorAdd\s\(.*\)\sat.*}
send_gdb "info threads\n"
gdb_expect -re  "\\s+(\\d+)\\s+AMDGPU Thread\\s+(\\d+\:\\d+:\\d+:\\d+)\\s+(\\(\\d+,\\d+,\\d+\\)/\\d+).*$gdb_prompt $" {
  set threadid "$expect_out(1,string)"
  set rocm_threadno "$expect_out(2,string)"
  set wave_id  "$expect_out(3,string)"
}

verbose $rocm_threadno
verbose $threadid
verbose $wave_id
regsub -all {[]*+.|()^$\[\\]} $wave_id {\\&} wave_id_re
verbose $wave_id_re

clean_restart ${binfile}

# Turn on non-stop mode.

# In nonstop mode gdb prompt is not the last string to consider in regex
# as it is lost between the other threads.
# For example
# Thread 5 "nonstop-mode" hit Breakpoint 1, VectorAdd () at ../../../git/gdb/testsuite/gdb.rocm/nonstop-mode.cpp:51
# 51    int tid = hipBlockIdx_x * hipBlockDim_x + hipThreadIdx_x;
# (gdb)
# Thread 6 "nonstop-mode" hit Breakpoint 1, VectorAdd () at ../../../git/gdb/testsuite/gdb.rocm/nonstop-mode.cpp:51
# 51    int tid = hipBlockIdx_x * hipBlockDim_x + hipThreadIdx_x;

gdb_test_no_output "set non-stop on"
gdb_test_no_output "set environment HIP_ENABLE_DEFERRED_LOADING=0"
gdb_breakpoint "VectorAdd" "allow-pending"
set test_name "run to VectorAdd Breakpoint"
send_gdb "run\n"
gdb_expect {
  -re "hit Breakpoint \[1-9\].*$gdb_prompt.*" { pass $test_name }
  timeout {fail "(timeout) run"}
}

# In non-stop mode when we do run after puting breakpoint in kernel all threads gets created
# so we need to wait until all thread info get display on gdb console.
sleep 1

gdb_test "thread $threadid" ".Switching to thread $threadid.*AMDGPU Thread.*"
gdb_test "continue -a" {.+Inferior\s[\d].+\sexited\snormally.+}
set test_name "run to VectorAdd Breakpoint after inferior exit"
send_gdb "run\n"
gdb_expect {
  -re "hit Breakpoint \[1-9\].*$gdb_prompt.*" { pass $test_name }
  timeout {fail "(timeout) run"}
}
sleep 1
gdb_test "thread $threadid" ".Switching to thread $threadid.*AMDGPU Thread.*"


# Check "info agents".
# vega10 sample output "1    (GPUID 39113) vega10      224   2240    44:00.0"
# vega20 sample output "1    (GPUID 45151) vega20      240   2400    0a:00.0"
gdb_test_sequence "info agents" "info agents" {
 {Id\s+Target Id\s+Device Name\s+Cores\s+Threads\s+PCI Slot}
 {\d+\s+AMDGPU Agent \([^\)]*\)\s+\w+\s+\d+\s+\d+\s+\w+:\d+\.\d}
}


# Check "info threads".
# Sample output:
#* 5    AMDGPU Thread 1.1 (0,0,0)/0 "bit_extract_kernel"      bit_extract_kernel () at bit_extract.cpp:38
#  6    AMDGPU Thread 1.2 (0,0,0)/1 "bit_extract_kernel"      __hip_get_block_dim_x ()
gdb_test_sequence "info threads" "info threads" {
 {Id\s+Target\s+Id\s+Frame}
 {\d+\s+AMDGPU\sThread\s\d+\:\d+:\d+:\d+}
}

sleep 1


# Show architecture info while debugging in device code.
# Sample output "The target architecture is set automatically (currently amdgcn:gfx906)"
gdb_test "show architecture" \
  {The target architecture is set to "auto" \(currently "amdgcn:gfx\d+"\)\.}

gdb_test_sequence "show convenience" "show convenience" {
 {\$_thread = \d+}
 {\$_wave_id = \"\(\d+,\d+,\d+\)/\d+\"}

}


# Check "info sharedlibrary"
# Sample output
# From                To                  Syms Read   Shared Object Library
# 0x00007ffbdfe05000  0x00007ffbdfe07a2c  Yes (*)     AMDGPU shared object [loaded from memory 0xab9900..0xac3470]
# 0x00007ffbdc201000  0x00007ffbdc201c94  Yes         AMDGPU shared object [loaded from memory 0x9b71d0..0x9bae28]
# gdb_test_sequence "info sharedlibrary" "info sharedlibrary" {
# {From\s+To\s+Syms\s+Read\s+Shared Object Library}
# {0x[0-9a-fA-F]+\s+0x[0-9a-fA-F]+\s+Yes\s\(\*\)\s+AMDGPU shared object.}
# {0x[0-9a-fA-F]+\s+0x[0-9a-fA-F]+\s+Yes\s+AMDGPU shared object.}
# }


# Check "info break".
# Sample output:
# Num     Type           Disp Enb Address            What
# 1       breakpoint     keep y   0x00007ffbdc2012dc in bit_extract_kernel() at bit_extract.cpp:38
#         breakpoint already hit 1 time
gdb_test_sequence "info break" "info break" {
 {Num\s+Type\s+Disp\sEnb Address\s+What}
 {\d+\s+breakpoint\s+keep\s+y}
 {breakpoint already hit\s\d+\stime}
}


# Check "info inferiors".
#   Num  Description       Executable
# * 1    process 34544     /home/amd/rohit/samples/0_Intro/bit_extract/bit_extrac
gdb_test_sequence "info inferiors" "info inferiors" {
 {Num\s+Description\s+Connection\s+Executable}
 {\*\s\d+\s+process\s+\d+}
}

gdb_test "disable 1"
gdb_test "continue -a" {.+Inferior\s\d+.+\sexited\snormally.+}
gdb_test "run" {.+Inferior\s[\d].+\sexited\snormally.+}
gdb_test "enable 1"
set test_name "run to VectorAdd after disable/enable Breakpoint No"
send_gdb "run\n"
gdb_expect {
  -re "hit Breakpoint \[1-9\].*$gdb_prompt.*" { pass $test_name }
  timeout {fail "(timeout) run"}
}

sleep 1
gdb_test "clear VectorAdd"
gdb_test "continue -a" {.+Inferior\s\d+.+\sexited\snormally.+}
gdb_test "start" {.+hit\sTemporary\sbreakpoint\s[\d].*}
gdb_test "continue" {.+Inferior\s[\d].+\sexited\snormally.+}

gdb_breakpoint "VectorAdd" "allow-pending"
set test_name "Again setting Breakpoint and running to Breakpoint after inferior exit"
send_gdb "run\n"
gdb_expect {
  -re "hit Breakpoint \[1-9\].*$gdb_prompt.*" { pass $test_name }
  timeout {fail "(timeout) run"}
}

sleep 1

gdb_test "continue -a" {.+Inferior\s[\d].+\sexited\snormally.+}


# Switch to all stop mode.
gdb_test_no_output "set non-stop off"
gdb_test "run" {.+hit\sBreakpoint\s\d+.+\sVectorAdd\s\(.*\)\sat.*}
gdb_test "continue" {.+hit\sBreakpoint\s\d+.+\sVectorAdd\s\(.*\)\sat.*}
gdb_test "disable 3"
gdb_test "continue" {.+Inferior\s[\d].+\sexited\snormally.+}
gdb_test "run" {.+Inferior\s[\d].+\sexited\snormally.+}
gdb_test "enable 3"
gdb_test "run" {.+hit\sBreakpoint\s[\d].+\sVectorAdd\s\(.*\)\sat.*}
gdb_test "clear VectorAdd"
gdb_test "continue" {.+Inferior\s[\d].+\sexited\snormally.+}

gdb_exit
}
