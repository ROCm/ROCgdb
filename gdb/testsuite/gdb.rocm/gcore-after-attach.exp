# Copyright (C) 2023 Free Software Foundation, Inc.
# Copyright (C) 2023 Advanced Micro Devices, Inc. All rights reserved.

# This file is part of GDB.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# When a ROCm program is executed outside of GDB, it might not
# initialize some debug related registers.  Without those registers
# initialized, GDB cannot show the position of waves in the dispatch
# group for waves launched before GDB got attached.  This test ensures
# that if a core dump is created for such wave, GDB will not be able to
# show wave's coordinates when opening the corefile.

load_lib rocm.exp

require allow_hipcc_tests
require can_spawn_for_attach

standard_testfile .cpp

if { [build_executable "failed to prepare"  ${testfile} ${srcfile} \
	{debug hip}] } {
    return -1
}

# Return 1 if the coordinates of the wave running are known, 0
# otherwise.
proc has_wave_coordinates {testname} {
  set ttmp_initialized -1
  gdb_test_multiple "info threads" $testname {
    -re "$::decimal *Thread\[^\\n\]*\\n" {
      exp_continue
    }
    -re "$::decimal *AMDGPU Wave *$::decimal:$::decimal:\\?:1 \\(\\?,\\?,\\?\\)/\\?\[^\\n\]*\\n" {
      set ttmp_initialized 0
      exp_continue
    }
    -re "$::decimal *AMDGPU Wave *$::decimal:$::decimal:$::decimal:1 \\(0,0,0\\)/0\[^\\n\]*\\n" {
      set ttmp_initialized 1
      exp_continue
    }
    -re "$::gdb_prompt " {
      gdb_assert {$ttmp_initialized != -1} $gdb_test_name
    }
  }
  return $ttmp_initialized
}

proc do_test {debug_enabled} {
  set spawn_id [spawn_wait_for_attach $::binfile]
  set prog_pid [spawn_id_get_pid $spawn_id]

  clean_restart
  if { ![gdb_attach $prog_pid] } {
    kill_wait_spawned_process $spawn_id
    return
  }

  set coord_known_after_attach \
    [has_wave_coordinates "coordinates known after attach"]
  if { $debug_enabled } {
    gdb_assert $coord_known_after_attach \
      "coordinates known when debug enabled"
  }

  set corefile_path $::binfile.core
  if {![rocm_generate_core_file $corefile_path]} {
    return
  }

  # Since we attached to the process, GDB is not using PTRACE_O_EXITKILL,
  # so when we later call clean_restart, we kill GDB and the spawned process
  # is free to go again.  However, because this process uses an infinite loop,
  # it will remain around using GPU resources until the runtest execution has
  # completed, which could affect other tests executed later in the session.
  # To avoid this, be sure to kill the process, and have TCL reap the wait
  # status.
  kill_wait_spawned_process $spawn_id

  # Reload the corefile.
  clean_restart $::binfile
  gdb_test "core-file $corefile_path" "Core was generated by.*" \
    "reload corefile"

  set coord_known_after_core_load \
    [has_wave_coordinates "coordinates known after core load"]

  gdb_assert {$coord_known_after_attach == $coord_known_after_core_load} \
    "identical coordinates"
}

foreach_with_prefix enable_debug {on off} {
  save_vars { ::env(HSA_ENABLE_DEBUG) } {
    if { $enable_debug } {
      setenv HSA_ENABLE_DEBUG 1
    } else {
      unset -nocomplain ::env(HSA_ENABLE_DEBUG)
    }

    with_rocm_gpu_lock {
      do_test $enable_debug
    }
  }
}
