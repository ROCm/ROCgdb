# Copyright (C) 2023-2024 Free Software Foundation, Inc.
# Copyright (C) 2023-2024 Advanced Micro Devices, Inc. All rights reserved.

# This file is part of GDB.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# This test exercises the case where a HIP application generates a fault
# on the GPU (pagefault, abort, or assert (false)) which triggers the
# runtime to generate a core dump.  The test will find the host and GPU
# core dumps, create a unified core using coremerge and open it in GDB.

load_lib rocm.exp

require allow_hipcc_tests

standard_testfile .cpp

if { [build_executable "failed to prepare" ${testfile} ${srcfile} \
      {debug hip}] } {
    return -1
}

# do_test FAULT
#   Run the test exercising generation of a core dump on fault FAULT.
#
# FAULT is one of "page", "abort",  or "assert", and selects which
#   fault the application should generate.
proc do_test { fault } {
    set coredump [rocm_core_find $::binfile {} $fault]

    if {$coredump eq ""} {
	untested "Could not generate a core file"
	return
    }

    check_sparse $coredump "core is sparse"

    remote_exec build "mv $coredump $coredump-$fault"

    if {$fault == "pagefault"} {
	set gpusig "SIGSEGV"
	set fault_loc "pagefault_kernel"
    } elseif {$fault == "abort"} {
	set gpusig "SIGABRT"
	set fault_loc "abort"
    } elseif {$fault == "assert"} {
	set gpusig "SIGABRT"
	set fault_loc "__assert_fail"
    }

    clean_restart $::binfile
    gdb_test "core-file $coredump-$fault" \
	[multi_line \
	  ".*" \
	  "Core was generated by .*" \
	  "Program terminated with signal SIGABRT.*" \
	  "Thread $::decimal \\(AMDGPU Wave \[^\r\n\]*\\) stopped because of $gpusig.*"] \
	"load corefile"

    set faulty_wave 0
    set aux_wave 0
    gdb_test_multiple "info thread" "identify waves" -lbl {
	-re "($::decimal) *AMDGPU Wave \[^\r\n\]*$fault_loc \[^\\n\]*" {
	    set faulty_wave $expect_out(1,string)
	    exp_continue
	}
	-re "($::decimal) *AMDGPU Wave \[^\r\n\]* aux_kernel \[^\\n\]*" {
	    set aux_wave $expect_out(1,string)
	    exp_continue
	}
	-re "$::gdb_prompt $" {
	    gdb_assert {($faulty_wave != 0) && ($aux_wave != 0)} $gdb_test_name
	}
    }

    # Check that we can access various variables from the scope of the faulty
    # thread.
    with_test_prefix "faulty_wave" {
	gdb_test \
	    "thread $faulty_wave" \
	    "Switching to thread $faulty_wave.*" \
	    "select faulty wave"
	# The fault might be reported in a child function.  Make sure to unwind
	# the frame to the top-level frame.
	gdb_test "frame function ${fault}_kernel" ".* ${fault}_kernel \\(.*"
	gdb_test "p local" "= 42"
	if {$fault == "pagefault"} {
	    gdb_test "p out == 0" " = false"
	}
	gdb_test "p some_global" " = 16"
    }

    # Similarly, make sure we can access data from threads which did not cause
    # any error.
    with_test_prefix "regular_wave" {
	gdb_test "thread $aux_wave" \
	    "Switching to thread $aux_wave.*" \
	    "select regular wave"
	gdb_test "p local" " = 72"
	gdb_test "p some_global" " = 16"
    }

    gdb_exit
}

with_rocm_gpu_lock {
    foreach_with_prefix fault {pagefault abort assert} {
	do_test $fault
    }
}
